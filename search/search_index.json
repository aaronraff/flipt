{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Flipt A feature flag solution that runs in your existing infrastructure. What is Flipt Flipt is an open source feature flag application that allows you to run experiments across services in your environment. This means that you can deploy Flipt within your existing infrastructure and not have to worry about your information being sent to a third party or the latency required to communicate across the internet. Flipt includes native client SDKs as well as a REST API so you can choose how to best integrate Flipt with your applications. For more on Flipt and it's concepts, take a look at the Concepts documentation. Beta Software Flipt is still considered beta software until the 1.0 release. This means that there are likely bugs and features/configuration may change between releases. Attempts will be made to maintain backwards compatibility whenever possible. Flipt Features Flipt enables you to add feature flag support to your existing applications, with a simple, single UI and API. This can range from simple on/off feature flags to more advanced use cases where you want to be able to rollout different versions of a feature to percentages of your users. Flipt features include: Fast. Written in Go. Optimized for performance Stand alone, easy to run and configure Ability to create advanced distribution rules to target segments of users Native GRPC client SDKs to integrate with your applications Simple REST API Modern UI and debug console Why Flipt Many organizations understand the benefit of using feature flags in production, so they choose to implement them themselves in their main application or monolith. As their organization grows, so does their infrastructure and functionality makes it's way into a multitude of other services. Many times those services aren't even implemented in the same language. This is where their original feature flag solution tends to break down as it cannot be easily adapted to those services or languages. This results in: Only being able to use feature flags in a subset of services. Having multiple sources of truth for feature flags depending on the service/implementation leading to unpredictability. Flipt solves all of these issues and more and enables you to focus on your applications, without having to worry about implementing your own feature flag solution that works across your infrastructure. On top of this, Flipt provides a nice, modern UI so that you can always monitor the state of your feature flags and experiments in a single place. Running Flipt Flipt is a single, self contained binary that you run on your own servers or cloud infrastructure. There are a multitude of benefits to running Flipt yourself, including: Security . No Flipt data leaves your servers and you don't have to open your systems to the outside world to communicate with Flipt. It all runs within your existing infrastructure. Speed . Since Flipt is co-located with your existing services, you do not have to communicate across the internet to another application running on the other side of the world which can add excessive latency and slow down your applications. Simplicity Flipt is a single binary with no external dependencies by default. What's Next Want to get up and running with Flipt? See Getting Started . For a more detailed guide on how to setup and run Flipt, checkout the Installation documentation. To learn how Flipt works, read up on it's Architecture . For more information on how to integrate Flipt with your existing applications, see the Integration guide. Author Website: Mark Phelps Twitter: @mark_a_phelps Email: mark.aaron.phelps at gmail.com","title":"Flipt"},{"location":"#flipt","text":"A feature flag solution that runs in your existing infrastructure.","title":"Flipt"},{"location":"#what-is-flipt","text":"Flipt is an open source feature flag application that allows you to run experiments across services in your environment. This means that you can deploy Flipt within your existing infrastructure and not have to worry about your information being sent to a third party or the latency required to communicate across the internet. Flipt includes native client SDKs as well as a REST API so you can choose how to best integrate Flipt with your applications. For more on Flipt and it's concepts, take a look at the Concepts documentation.","title":"What is Flipt"},{"location":"#beta-software","text":"Flipt is still considered beta software until the 1.0 release. This means that there are likely bugs and features/configuration may change between releases. Attempts will be made to maintain backwards compatibility whenever possible.","title":"Beta Software"},{"location":"#flipt-features","text":"Flipt enables you to add feature flag support to your existing applications, with a simple, single UI and API. This can range from simple on/off feature flags to more advanced use cases where you want to be able to rollout different versions of a feature to percentages of your users. Flipt features include: Fast. Written in Go. Optimized for performance Stand alone, easy to run and configure Ability to create advanced distribution rules to target segments of users Native GRPC client SDKs to integrate with your applications Simple REST API Modern UI and debug console","title":"Flipt Features"},{"location":"#why-flipt","text":"Many organizations understand the benefit of using feature flags in production, so they choose to implement them themselves in their main application or monolith. As their organization grows, so does their infrastructure and functionality makes it's way into a multitude of other services. Many times those services aren't even implemented in the same language. This is where their original feature flag solution tends to break down as it cannot be easily adapted to those services or languages. This results in: Only being able to use feature flags in a subset of services. Having multiple sources of truth for feature flags depending on the service/implementation leading to unpredictability. Flipt solves all of these issues and more and enables you to focus on your applications, without having to worry about implementing your own feature flag solution that works across your infrastructure. On top of this, Flipt provides a nice, modern UI so that you can always monitor the state of your feature flags and experiments in a single place.","title":"Why Flipt"},{"location":"#running-flipt","text":"Flipt is a single, self contained binary that you run on your own servers or cloud infrastructure. There are a multitude of benefits to running Flipt yourself, including: Security . No Flipt data leaves your servers and you don't have to open your systems to the outside world to communicate with Flipt. It all runs within your existing infrastructure. Speed . Since Flipt is co-located with your existing services, you do not have to communicate across the internet to another application running on the other side of the world which can add excessive latency and slow down your applications. Simplicity Flipt is a single binary with no external dependencies by default.","title":"Running Flipt"},{"location":"#whats-next","text":"Want to get up and running with Flipt? See Getting Started . For a more detailed guide on how to setup and run Flipt, checkout the Installation documentation. To learn how Flipt works, read up on it's Architecture . For more information on how to integrate Flipt with your existing applications, see the Integration guide.","title":"What's Next"},{"location":"#author","text":"Website: Mark Phelps Twitter: @mark_a_phelps Email: mark.aaron.phelps at gmail.com","title":"Author"},{"location":"architecture/","text":"Architecture The overall Flipt server architecture is shown in this diagram: Note Arrows indicate request or connection initiation direction, not necessarily dataflow direction. As shown in the above diagram, the Flipt application is made up of three main components: Flipt Backend Service Flipt REST API Flipt Web UI All three of these components run side by side in a single binary. The UI and REST API are served on the same port ( 8080 by default) and the GRPC Backend Service is served on 9000 by default. Backend Service The Flipt Backend Service is the main entrypoint to the application and implements all of the business logic for Flipt. This is what users of the gRPC client SDKs will communicate with, allowing for fast, efficient communication with your applications. REST API The Flipt REST API is implemented on top of the Backend Service using gRPC Gateway (described below). The REST API is served under /api/v1 and allows all actions that the client SDKs allow. Web UI The Flipt Web UI is a modern, minimalist UI to allow you to easily setup and monitor your feature flags and experiments. It's served as a JavaScript Single Page Application (SPA) and communicates with the Flipt Backend Service through the REST API. A guide to using the UI for the first time can be found in the Getting Started documentation. Technologies Flipt is built using several amazing open source technologies including: Go Programming Language gRPC gRPC Gateway Vue.js Bulma Buefy A brief description of why each technology was chosen is below. Go From the Go documentation: Go makes it easy to build simple, reliable and efficient software. These are all goals that Flipt also aspires to. Flipt was written in Go mainly because of it's ability to produce bulletproof systems software as as single binary for multiple architectures. This allows Flipt to easily be deployed in almost any environment since it's as simple as copying a compiled binary. GRPC gRPC is a high performance, open source RPC framework created by Google. gRPC allows Flipt to be performant by eliminating much of the overhead incurred by using standard HTTP for communication. gRPC also has the benefit of being able to generate client SDKs in many different languages from a single Protobuf file. This allows you easily integrate your services with Flipt regardless of the language they are written in. GRPC Gateway While awesome, gRPC might not be for everyone. gRPC Gateway is a reverse-proxy server which translates a RESTful JSON API into gRPC. This allows Flipt to implement a REST API as well as the gRPC API described above. This means that the REST API follows the same codepaths as the gRPC service that Flipt implements, allowing for reduced bugs and a simpler architecture. The Flipt UI is also built on top of the REST API provided by gRPC gateway. Vue.js Vue.js is a minimal, modern and performant JavaScript framework that makes it easy to implement reactive frontend applications such as the Flipt UI. Vue.js was chosen because of it's rich ecosystem as well as ease of use to get started. The Flipt UI is a Single Page Application (SPA) written in JavaScript using Vue.js, that communicates with with the Flipt backend over the Flipt REST API. This means that the UI uses the same API that end clients do, meaning that anything you can do with the Flipt API, you can do in the UI and vice versa. Bulma Bulma is a free, open source CSS framework based on Flexbox. It makes it easy to create nice looking user interfaces with minimal CSS. Buefy Buefy creates lightweight UI components for Vue.js based on Bulma. The Flipt UI was built using several Buefy components that greatly enhanced the speed of development.","title":"Architecture"},{"location":"architecture/#architecture","text":"The overall Flipt server architecture is shown in this diagram: Note Arrows indicate request or connection initiation direction, not necessarily dataflow direction. As shown in the above diagram, the Flipt application is made up of three main components: Flipt Backend Service Flipt REST API Flipt Web UI All three of these components run side by side in a single binary. The UI and REST API are served on the same port ( 8080 by default) and the GRPC Backend Service is served on 9000 by default.","title":"Architecture"},{"location":"architecture/#backend-service","text":"The Flipt Backend Service is the main entrypoint to the application and implements all of the business logic for Flipt. This is what users of the gRPC client SDKs will communicate with, allowing for fast, efficient communication with your applications.","title":"Backend Service"},{"location":"architecture/#rest-api","text":"The Flipt REST API is implemented on top of the Backend Service using gRPC Gateway (described below). The REST API is served under /api/v1 and allows all actions that the client SDKs allow.","title":"REST API"},{"location":"architecture/#web-ui","text":"The Flipt Web UI is a modern, minimalist UI to allow you to easily setup and monitor your feature flags and experiments. It's served as a JavaScript Single Page Application (SPA) and communicates with the Flipt Backend Service through the REST API. A guide to using the UI for the first time can be found in the Getting Started documentation.","title":"Web UI"},{"location":"architecture/#technologies","text":"Flipt is built using several amazing open source technologies including: Go Programming Language gRPC gRPC Gateway Vue.js Bulma Buefy A brief description of why each technology was chosen is below.","title":"Technologies"},{"location":"architecture/#go","text":"From the Go documentation: Go makes it easy to build simple, reliable and efficient software. These are all goals that Flipt also aspires to. Flipt was written in Go mainly because of it's ability to produce bulletproof systems software as as single binary for multiple architectures. This allows Flipt to easily be deployed in almost any environment since it's as simple as copying a compiled binary.","title":"Go"},{"location":"architecture/#grpc","text":"gRPC is a high performance, open source RPC framework created by Google. gRPC allows Flipt to be performant by eliminating much of the overhead incurred by using standard HTTP for communication. gRPC also has the benefit of being able to generate client SDKs in many different languages from a single Protobuf file. This allows you easily integrate your services with Flipt regardless of the language they are written in.","title":"GRPC"},{"location":"architecture/#grpc-gateway","text":"While awesome, gRPC might not be for everyone. gRPC Gateway is a reverse-proxy server which translates a RESTful JSON API into gRPC. This allows Flipt to implement a REST API as well as the gRPC API described above. This means that the REST API follows the same codepaths as the gRPC service that Flipt implements, allowing for reduced bugs and a simpler architecture. The Flipt UI is also built on top of the REST API provided by gRPC gateway.","title":"GRPC Gateway"},{"location":"architecture/#vuejs","text":"Vue.js is a minimal, modern and performant JavaScript framework that makes it easy to implement reactive frontend applications such as the Flipt UI. Vue.js was chosen because of it's rich ecosystem as well as ease of use to get started. The Flipt UI is a Single Page Application (SPA) written in JavaScript using Vue.js, that communicates with with the Flipt backend over the Flipt REST API. This means that the UI uses the same API that end clients do, meaning that anything you can do with the Flipt API, you can do in the UI and vice versa.","title":"Vue.js"},{"location":"architecture/#bulma","text":"Bulma is a free, open source CSS framework based on Flexbox. It makes it easy to create nice looking user interfaces with minimal CSS.","title":"Bulma"},{"location":"architecture/#buefy","text":"Buefy creates lightweight UI components for Vue.js based on Bulma. The Flipt UI was built using several Buefy components that greatly enhanced the speed of development.","title":"Buefy"},{"location":"concepts/","text":"Concepts This document describes the basic concepts of Flipt. More information on how to use Flipt is noted in the Getting Started documentation. Flags Flags are the basic unit in the Flipt ecosystem. Flags represent experiments or features that you want to be able to enable or disable for users of your applications. For example, a flag named new-contact-page , could be used to determine whether or not a given user sees the latest version of a contact us page that you are working on when they visit your homepage. Flags can be used as simple on/off toggles or with variants and rules to support more elaborate usecases. Variants Variants are options for flags. For example, if you have a flag colorscheme that determines which main colors your users see when they log in to your application, then possible variants could be include blue , green or red . Note Variant keys must be unique for a given flag. Segments Segments allow you to split your userbase or audience up into predefined slices. This is a powerful feature that enables targeting groups to determine if a flag or variant applies to them. An example segment could be new-users . Tip Segments are global across the Flipt application so they can be used with multiple flags. Constraints Constraints allow you to determine which segment a given entity is a part of. For example, for a user to fall into the above new-users segment, you may want to check their finished_onboarding property. All constraints have a property , type , operator and optionally a value . property the context key to match against, see the context section below type one of the basic types: string, number or boolean operator how to compare the property against the value value (optional) what to compare with the operator Note In order for a segment to match, it must match ALL of it's constraints. Rules Rules allow you to tie your flags, variants and segments together by specifying which segments are targeted by which variants. Rules can be as simple as IF IN segment THEN RETURN variant_a or they can be more rich by using distribution logic to rollout features on a percent basis. Continuing our previous example, we may want to return the flag variant blue for all entities in the new-users segment. This would be configured like so: Note As shown, rules are evaluated in order per their rank from 1-N. The first rule that matches wins. Once created, rules can be re-ordered to change how they are evaluated. Distributions Distributions allow you to rollout different variants of your flag to percentages of your userbase based on your rules. Let's say that instead of always showing the blue variant to your new-users segment, you want to show blue to 30% of new-users , red to 10%, and green to the remaining 60%. You would accomplish this using rules with distributions: This is an extremely powerful feature of Flipt that can help you seamlessly deploy new features of your applications to your users while also limiting reach of potential bugs. Evaluation Evaluation is the process of sending requests to the Flipt server to process and determine if that request matches any of your segments, and if so which variant to return. In the above example involving colors, evaluation is where you send information about your current user to determine if they are a new-user , and which color ( blue , red , or green ) that they should see for their main colorscheme. Entities Evaluation works by uniquely identifying each thing that you want to compare against your segments and flags. We call this an entity in the Flipt ecosystem. More often than not this will be a user, but we didn't want to make any assumptions on how your application works, which is why entity was chosen. entity what you want to test against in your application For Flipt to successfully determine which bucket your entities fall into, it must have a way to uniquely identify them. This is the entityId and it is a simple string. It's up to you what that entityId is. It could be a: email address userID ip address physical address etc Anything that is unique enough for your application and it's requirements. Context The final piece of the puzzle is context. Context allows Flipt to determine which segment your entity falls into by comparing it to all of the possible constraints that you defined. context metadata associated with your entity, used to determine which if any segments that entity is a member of Examples of context could include: isAdmin favoriteColor country freeUser Think of these as pieces of information that are usually not unique, but that can be used to split your entities into your segments. You can include as much or as little context for each entity as you want, however the more context that you provide, the more likely it is that a entity will match one of your segments. In Flipt, context is a simple map of key-value pairs where the key is the property to match against all constraints, and the value is what is compared.","title":"Concepts"},{"location":"concepts/#concepts","text":"This document describes the basic concepts of Flipt. More information on how to use Flipt is noted in the Getting Started documentation.","title":"Concepts"},{"location":"concepts/#flags","text":"Flags are the basic unit in the Flipt ecosystem. Flags represent experiments or features that you want to be able to enable or disable for users of your applications. For example, a flag named new-contact-page , could be used to determine whether or not a given user sees the latest version of a contact us page that you are working on when they visit your homepage. Flags can be used as simple on/off toggles or with variants and rules to support more elaborate usecases.","title":"Flags"},{"location":"concepts/#variants","text":"Variants are options for flags. For example, if you have a flag colorscheme that determines which main colors your users see when they log in to your application, then possible variants could be include blue , green or red . Note Variant keys must be unique for a given flag.","title":"Variants"},{"location":"concepts/#segments","text":"Segments allow you to split your userbase or audience up into predefined slices. This is a powerful feature that enables targeting groups to determine if a flag or variant applies to them. An example segment could be new-users . Tip Segments are global across the Flipt application so they can be used with multiple flags.","title":"Segments"},{"location":"concepts/#constraints","text":"Constraints allow you to determine which segment a given entity is a part of. For example, for a user to fall into the above new-users segment, you may want to check their finished_onboarding property. All constraints have a property , type , operator and optionally a value . property the context key to match against, see the context section below type one of the basic types: string, number or boolean operator how to compare the property against the value value (optional) what to compare with the operator Note In order for a segment to match, it must match ALL of it's constraints.","title":"Constraints"},{"location":"concepts/#rules","text":"Rules allow you to tie your flags, variants and segments together by specifying which segments are targeted by which variants. Rules can be as simple as IF IN segment THEN RETURN variant_a or they can be more rich by using distribution logic to rollout features on a percent basis. Continuing our previous example, we may want to return the flag variant blue for all entities in the new-users segment. This would be configured like so: Note As shown, rules are evaluated in order per their rank from 1-N. The first rule that matches wins. Once created, rules can be re-ordered to change how they are evaluated.","title":"Rules"},{"location":"concepts/#distributions","text":"Distributions allow you to rollout different variants of your flag to percentages of your userbase based on your rules. Let's say that instead of always showing the blue variant to your new-users segment, you want to show blue to 30% of new-users , red to 10%, and green to the remaining 60%. You would accomplish this using rules with distributions: This is an extremely powerful feature of Flipt that can help you seamlessly deploy new features of your applications to your users while also limiting reach of potential bugs.","title":"Distributions"},{"location":"concepts/#evaluation","text":"Evaluation is the process of sending requests to the Flipt server to process and determine if that request matches any of your segments, and if so which variant to return. In the above example involving colors, evaluation is where you send information about your current user to determine if they are a new-user , and which color ( blue , red , or green ) that they should see for their main colorscheme.","title":"Evaluation"},{"location":"concepts/#entities","text":"Evaluation works by uniquely identifying each thing that you want to compare against your segments and flags. We call this an entity in the Flipt ecosystem. More often than not this will be a user, but we didn't want to make any assumptions on how your application works, which is why entity was chosen. entity what you want to test against in your application For Flipt to successfully determine which bucket your entities fall into, it must have a way to uniquely identify them. This is the entityId and it is a simple string. It's up to you what that entityId is. It could be a: email address userID ip address physical address etc Anything that is unique enough for your application and it's requirements.","title":"Entities"},{"location":"concepts/#context","text":"The final piece of the puzzle is context. Context allows Flipt to determine which segment your entity falls into by comparing it to all of the possible constraints that you defined. context metadata associated with your entity, used to determine which if any segments that entity is a member of Examples of context could include: isAdmin favoriteColor country freeUser Think of these as pieces of information that are usually not unique, but that can be used to split your entities into your segments. You can include as much or as little context for each entity as you want, however the more context that you provide, the more likely it is that a entity will match one of your segments. In Flipt, context is a simple map of key-value pairs where the key is the property to match against all constraints, and the value is what is compared.","title":"Context"},{"location":"configuration/","text":"Configuration There are two ways to configure Flipt: using a configuration file or through environment variables. Configuration File The default way that Flipt is configured is with the use of a configuration file default.yml . This file is read when Flipt starts up and configures several important properties for the server. You can edit any of these properties to your liking, and on restart Flipt will pick up the new changes. Note These defaults are commented out in default.yml to give you an idea of what they are. To change them you'll first need to uncomment them. These properties are as follows: Property Description Default log.level Level at which messages are logged (trace, debug, info, warn, error, fatal, panic) info ui.enabled Enable UI and API docs true cors.enabled Enable CORS support false cors.allowed_origins Sets Access-Control-Allow-Origin header on server \"*\" (all domains) cache.memory.enabled Enable in-memory caching false cache.memory.items Number of items in-memory cache can hold 500 server.protocol http or https http server.host The host address on which to serve the Flipt application 0.0.0.0 server.http_port The HTTP port on which to serve the Flipt REST API and UI 8080 server.https_port The HTTPS port on which to serve the Flipt REST API and UI 443 server.grpc_port The port on which to serve the Flipt GRPC server 9000 server.cert_file Path to the certificate file (if protocol is set to https ) server.cert_key Path to the certificate key file (if protocol is set to https ) db.url URL to access Flipt database file:/var/opt/flipt/flipt.db db.migrations.path Where the Flipt database migration files are kept /etc/flipt/config/migrations Using Environment Variables All options in the configuration file can be overridden using environment variables using the syntax: FLIPT_ SectionName _ KeyName Tip Using environment variables to override defaults is especially helpful when running with Docker as described in the Installation documentation. Everything should be upper case, . should be replaced by _ . For example, given these configuration settings: server : grpc_port : 9000 db : url : file:/var/opt/flipt/flipt.db You can override them using: export FLIPT_SERVER_GRPC_PORT = 9001 export FLIPT_DB_URL = postgres://postgres@localhost:5432/flipt?sslmode=disable Databases Flipt supports both SQLite and Postgres databases as of v0.5.0 . SQLite is enabled by default for simplicity, however you should use Postgres if you intend to run multiple copies of Flipt in a high availability configuration. The database connection can be configured as follows: SQLite db : # file: informs flipt to use SQLite url : file:/var/opt/flipt/flipt.db Postgres db : url : postgres://postgres@localhost:5432/flipt?sslmode=disable Note The Postgres database must exist and be up and running before Flipt will be able to connect to it. Migrations From time to time the Flipt database must be updated with new schema. To accomplish this, Flipt includes a migrate command that will run any pending database migrations for you. If Flipt is started and there are pending migrations, you will see the following error in the console: migrations pending, please backup your database and run ` flipt migrate ` If it is your first run of Flipt, all migrations will automatically be run before starting the Flipt server. Warning You should backup your database before running flipt migrate to ensure that no data is lost if an error occurs during migration. If running Flipt via Docker, you can run the migrations in a seperate container before starting Flipt by running: docker run -it markphelps/flipt:latest /bin/sh -c ./flipt migrate Caching In-Memory In-memory caching is currently only available for flags. When enabled, in-memory caching has been shown to speed up the fetching of individual flags by 10x. To enable caching set the following in your config: cache : memory : enabled : true Work is planned to add caching support to rule evaluation soon. Warning Enabling in-memory caching when running more that one instance of Flipt is not advised as it will lead to unpredictable results. Metrics Flipt exposes Prometheus metrics at the /metrics HTTP endpoint. To see which metrics are currently supported, point your browser to FLIPT_HOST/metrics (ex: localhost:8080/metrics ). You should see a bunch of metrics being recorded such as: flipt_cache_hit_total{cache= memory ,type= flag } 1 flipt_cache_miss_total{cache= memory ,type= flag } 1 ... go_gc_duration_seconds{quantile= 0 } 8.641e-06 go_gc_duration_seconds{quantile= 0.25 } 2.499e-05 go_gc_duration_seconds{quantile= 0.5 } 3.5359e-05 go_gc_duration_seconds{quantile= 0.75 } 6.6594e-05 go_gc_duration_seconds{quantile= 1 } 0.00026651 go_gc_duration_seconds_sum 0.000402094 go_gc_duration_seconds_count 5 ... Authentication There is currently no built in authentication, authorization or encryption as Flipt was designed to work inside your trusted architecture and not be exposed publicly. If you do wish to expose the Flipt dashboard and REST API publicly using HTTP Basic Authentication, you can do so by using a reverse proxy. There is an example provided in the GitHub repository showing how this could work.","title":"Configuration"},{"location":"configuration/#configuration","text":"There are two ways to configure Flipt: using a configuration file or through environment variables.","title":"Configuration"},{"location":"configuration/#configuration-file","text":"The default way that Flipt is configured is with the use of a configuration file default.yml . This file is read when Flipt starts up and configures several important properties for the server. You can edit any of these properties to your liking, and on restart Flipt will pick up the new changes. Note These defaults are commented out in default.yml to give you an idea of what they are. To change them you'll first need to uncomment them. These properties are as follows: Property Description Default log.level Level at which messages are logged (trace, debug, info, warn, error, fatal, panic) info ui.enabled Enable UI and API docs true cors.enabled Enable CORS support false cors.allowed_origins Sets Access-Control-Allow-Origin header on server \"*\" (all domains) cache.memory.enabled Enable in-memory caching false cache.memory.items Number of items in-memory cache can hold 500 server.protocol http or https http server.host The host address on which to serve the Flipt application 0.0.0.0 server.http_port The HTTP port on which to serve the Flipt REST API and UI 8080 server.https_port The HTTPS port on which to serve the Flipt REST API and UI 443 server.grpc_port The port on which to serve the Flipt GRPC server 9000 server.cert_file Path to the certificate file (if protocol is set to https ) server.cert_key Path to the certificate key file (if protocol is set to https ) db.url URL to access Flipt database file:/var/opt/flipt/flipt.db db.migrations.path Where the Flipt database migration files are kept /etc/flipt/config/migrations","title":"Configuration File"},{"location":"configuration/#using-environment-variables","text":"All options in the configuration file can be overridden using environment variables using the syntax: FLIPT_ SectionName _ KeyName Tip Using environment variables to override defaults is especially helpful when running with Docker as described in the Installation documentation. Everything should be upper case, . should be replaced by _ . For example, given these configuration settings: server : grpc_port : 9000 db : url : file:/var/opt/flipt/flipt.db You can override them using: export FLIPT_SERVER_GRPC_PORT = 9001 export FLIPT_DB_URL = postgres://postgres@localhost:5432/flipt?sslmode=disable","title":"Using Environment Variables"},{"location":"configuration/#databases","text":"Flipt supports both SQLite and Postgres databases as of v0.5.0 . SQLite is enabled by default for simplicity, however you should use Postgres if you intend to run multiple copies of Flipt in a high availability configuration. The database connection can be configured as follows:","title":"Databases"},{"location":"configuration/#sqlite","text":"db : # file: informs flipt to use SQLite url : file:/var/opt/flipt/flipt.db","title":"SQLite"},{"location":"configuration/#postgres","text":"db : url : postgres://postgres@localhost:5432/flipt?sslmode=disable Note The Postgres database must exist and be up and running before Flipt will be able to connect to it.","title":"Postgres"},{"location":"configuration/#migrations","text":"From time to time the Flipt database must be updated with new schema. To accomplish this, Flipt includes a migrate command that will run any pending database migrations for you. If Flipt is started and there are pending migrations, you will see the following error in the console: migrations pending, please backup your database and run ` flipt migrate ` If it is your first run of Flipt, all migrations will automatically be run before starting the Flipt server. Warning You should backup your database before running flipt migrate to ensure that no data is lost if an error occurs during migration. If running Flipt via Docker, you can run the migrations in a seperate container before starting Flipt by running: docker run -it markphelps/flipt:latest /bin/sh -c ./flipt migrate","title":"Migrations"},{"location":"configuration/#caching","text":"","title":"Caching"},{"location":"configuration/#in-memory","text":"In-memory caching is currently only available for flags. When enabled, in-memory caching has been shown to speed up the fetching of individual flags by 10x. To enable caching set the following in your config: cache : memory : enabled : true Work is planned to add caching support to rule evaluation soon. Warning Enabling in-memory caching when running more that one instance of Flipt is not advised as it will lead to unpredictable results.","title":"In-Memory"},{"location":"configuration/#metrics","text":"Flipt exposes Prometheus metrics at the /metrics HTTP endpoint. To see which metrics are currently supported, point your browser to FLIPT_HOST/metrics (ex: localhost:8080/metrics ). You should see a bunch of metrics being recorded such as: flipt_cache_hit_total{cache= memory ,type= flag } 1 flipt_cache_miss_total{cache= memory ,type= flag } 1 ... go_gc_duration_seconds{quantile= 0 } 8.641e-06 go_gc_duration_seconds{quantile= 0.25 } 2.499e-05 go_gc_duration_seconds{quantile= 0.5 } 3.5359e-05 go_gc_duration_seconds{quantile= 0.75 } 6.6594e-05 go_gc_duration_seconds{quantile= 1 } 0.00026651 go_gc_duration_seconds_sum 0.000402094 go_gc_duration_seconds_count 5 ...","title":"Metrics"},{"location":"configuration/#authentication","text":"There is currently no built in authentication, authorization or encryption as Flipt was designed to work inside your trusted architecture and not be exposed publicly. If you do wish to expose the Flipt dashboard and REST API publicly using HTTP Basic Authentication, you can do so by using a reverse proxy. There is an example provided in the GitHub repository showing how this could work.","title":"Authentication"},{"location":"development/","text":"Development The following are instructions for setting up your machine for Flipt development. Requirements Before starting, make sure you have the following installed: GCC Compiler SQLite Go 1.12+ Protoc Compiler Setup Clone this repo: git clone https://github.com/markphelps/flipt Run make setup to download dependencies Run make test to execute the test suite Run make dev to build and run in development mode Run make help to see a full list of possible make commands Go Modules Flipt uses Go 1.12 with Go Modules enabled. To reliably build Flipt, make sure you clone it to a location outside of your $GOPATH or set the environment variable GO111MODULE=on . For more info see: https://github.com/golang/go/wiki/Modules#how-to-install-and-activate-module-support . Vagrant You can also easily get started with a development environment running in a VM using Vagrant and Virtual Box . Once you have Vagrant and Virtual Box installed you can cd into either the dev/ubuntu or dev/centos directories and run vagrant up . This will provision a VM that installs the necessary dev dependencies and runs the Flipt test suite. Once the provisioning process is complete, run: $ vagrant ssh $ cd ~/app/flipt $ make dev This will run Flipt in development mode inside your VM. Configuration Configuration for running when developing Flipt can be found at ./config/local.yml . To run Flipt with this configuration, run: make dev Changes Changing certain types of files such as the protobuf, ui or documentation files require re-building before they will be picked up in new versions of the binary. Updating .proto Files After changing flipt.proto , you'll need to run make proto . This will regenerate the following files: flipt.pb.go flipt.pb.gw.go Updating assets Running make assets will regenerate the embedded assets (ui, api documentation) so that the next time make dev is run they will be included. UI components The UI is built using Yarn and webpack and is also statically compiled into the Flipt binary. The ui/README.md has more information on how to build the UI and also how to run it locally during development.","title":"Development"},{"location":"development/#development","text":"The following are instructions for setting up your machine for Flipt development.","title":"Development"},{"location":"development/#requirements","text":"Before starting, make sure you have the following installed: GCC Compiler SQLite Go 1.12+ Protoc Compiler","title":"Requirements"},{"location":"development/#setup","text":"Clone this repo: git clone https://github.com/markphelps/flipt Run make setup to download dependencies Run make test to execute the test suite Run make dev to build and run in development mode Run make help to see a full list of possible make commands","title":"Setup"},{"location":"development/#go-modules","text":"Flipt uses Go 1.12 with Go Modules enabled. To reliably build Flipt, make sure you clone it to a location outside of your $GOPATH or set the environment variable GO111MODULE=on . For more info see: https://github.com/golang/go/wiki/Modules#how-to-install-and-activate-module-support .","title":"Go Modules"},{"location":"development/#vagrant","text":"You can also easily get started with a development environment running in a VM using Vagrant and Virtual Box . Once you have Vagrant and Virtual Box installed you can cd into either the dev/ubuntu or dev/centos directories and run vagrant up . This will provision a VM that installs the necessary dev dependencies and runs the Flipt test suite. Once the provisioning process is complete, run: $ vagrant ssh $ cd ~/app/flipt $ make dev This will run Flipt in development mode inside your VM.","title":"Vagrant"},{"location":"development/#configuration","text":"Configuration for running when developing Flipt can be found at ./config/local.yml . To run Flipt with this configuration, run: make dev","title":"Configuration"},{"location":"development/#changes","text":"Changing certain types of files such as the protobuf, ui or documentation files require re-building before they will be picked up in new versions of the binary.","title":"Changes"},{"location":"development/#updating-proto-files","text":"After changing flipt.proto , you'll need to run make proto . This will regenerate the following files: flipt.pb.go flipt.pb.gw.go","title":"Updating .proto Files"},{"location":"development/#updating-assets","text":"Running make assets will regenerate the embedded assets (ui, api documentation) so that the next time make dev is run they will be included.","title":"Updating assets"},{"location":"development/#ui-components","text":"The UI is built using Yarn and webpack and is also statically compiled into the Flipt binary. The ui/README.md has more information on how to build the UI and also how to run it locally during development.","title":"UI components"},{"location":"getting_started/","text":"Getting Started This document describes how to get started with the Flipt UI. Once you have your application integrated with the Flipt backend, it's time to create some flags to evaluate. This documentation will walk you through creating your first flag, segment, set of rules and finally using the debug console to evaluate everything. For more information on any of the concepts described here, please see the Concepts documentation. Setup Before getting started, make sure the Flipt server is up and running on your host on your chosen ports. See Installation for more. In this example we'll use the default location of http://localhost:8080 . Creating a Flag and Variants Now we'll create a flag and variants that we will use to evaluate against. Create a Flag A flag is the basic entity in Flipt. Flags can represent features in your applications that you want to enable/disable for your users. To create a flag: Open the UI at http://localhost:8080 . Click New Flag . Populate the details of the flag as shown. Click Enabled so the flag will be enabled once created. Click Create . You should see the message Flag created! . Create Variants Variants allow you to return different values for your flags based on rules that you define. To create a variant: On the Flag Details page for the new flag you created, click New Variant . Populate the details of the variant as shown. Click Add Variant . Create one more variant populating the information as you wish. You should see the message Variant added! . Click Flags in the navigation menu and you should now see your newly created flag in the list. Creating a Segment and Constraints Next we'll create a segment with a constraint that will be used to determine the reach of your flag. Create a Segment Segments are used to split your userbase into subsets. To create a segment: From the main page click Segments . Click New Segment . Populate the details of the segment as shown. Click Create . You should see the message Segment created! . Create a Constraint Constraints are used to target a specific segment. Note Constraints are not required to match a segment. A segment with no constraints will match every request by default. To create a constraint: On the Segment Details page for the new segment you created, click New Constraint . Populate the details of the constraint as shown. Click Add Constraint . You should see the message Constraint added! . Click Segments in the navigation menu and you should now see your newly created segment in the list. Creating a Rule and Distributions Finally we'll create a rule and set of distributions for your flag and variants. Rules and distributions allow you to define which variant gets returned when you evaluate a specific flag that falls into a given segment. To create a rule and distribution: Go back to the flag you created at the beginning. Click Targeting . Click New Rule . Under Segment: choose the segment you created earlier. Under Then serve: choose A Percentage Rollout . You should see your two variants that you created earlier, with a percentage of 50% each next to them. Click Add Rule . You should see the message Rule added! . You just created your first rule and distribution. A distribution is a way of assigning a percentage for which entities evaluated get a specific variant. The higher the percentage assigned, the more likely it is that any entity will get that specific variant. Note You could just as easily have picked a single variant instead of A Percentage Rollout when setting up your rule. This would effectively mean you have a single distribution, a variant with 100% chance of being returned. Evaluating with the Debug Console After creating the above flag, segment and targeting rule, you're now ready to test how this would work in your application. Fortunately the Flipt UI contains a Debug Console to allow you to experiment with different evaluation requests to see how they would be evaluated. The main ideas behind how evaluation works is described in more detail in the Concepts documentation. To test evaluation: Navigate to the Targeting section for your flag that you created above. Scroll down to the Debug Console section and click into the left pane where you will see a JSON payload. This represents the body of the request that will be evaluated. Notice the flagKey matches the key field of your flag. Notice that entityId is prepopulated with a random UUID. This represents the ID that you would use to uniquely identify entities (ex: users) that you want to test against your flags. Note that the context object is prepopulated as well. This corresponds to the properties that will be evaluated to determine if your request matches any constraints of your segments. Update the context object as shown. Click Debug . Note the Response pane to the right has been populated with the evaluation response from the server, informing you that this request would match your segment that you created earlier, and return one of the variants defined. Experiment with different values for the context and entityId fields. Tip You can click Reset to populate a new example request in the Request pane. This will also generate a fresh UUID for the entityId field. That's it! You're now ready to integrate Flipt into your application and start defining your own flags and segments that will enable you to seamlessly rollout new features to your users while reducing risk.","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"This document describes how to get started with the Flipt UI. Once you have your application integrated with the Flipt backend, it's time to create some flags to evaluate. This documentation will walk you through creating your first flag, segment, set of rules and finally using the debug console to evaluate everything. For more information on any of the concepts described here, please see the Concepts documentation.","title":"Getting Started"},{"location":"getting_started/#setup","text":"Before getting started, make sure the Flipt server is up and running on your host on your chosen ports. See Installation for more. In this example we'll use the default location of http://localhost:8080 .","title":"Setup"},{"location":"getting_started/#creating-a-flag-and-variants","text":"Now we'll create a flag and variants that we will use to evaluate against.","title":"Creating a Flag and Variants"},{"location":"getting_started/#create-a-flag","text":"A flag is the basic entity in Flipt. Flags can represent features in your applications that you want to enable/disable for your users. To create a flag: Open the UI at http://localhost:8080 . Click New Flag . Populate the details of the flag as shown. Click Enabled so the flag will be enabled once created. Click Create . You should see the message Flag created! .","title":"Create a Flag"},{"location":"getting_started/#create-variants","text":"Variants allow you to return different values for your flags based on rules that you define. To create a variant: On the Flag Details page for the new flag you created, click New Variant . Populate the details of the variant as shown. Click Add Variant . Create one more variant populating the information as you wish. You should see the message Variant added! . Click Flags in the navigation menu and you should now see your newly created flag in the list.","title":"Create Variants"},{"location":"getting_started/#creating-a-segment-and-constraints","text":"Next we'll create a segment with a constraint that will be used to determine the reach of your flag.","title":"Creating a Segment and Constraints"},{"location":"getting_started/#create-a-segment","text":"Segments are used to split your userbase into subsets. To create a segment: From the main page click Segments . Click New Segment . Populate the details of the segment as shown. Click Create . You should see the message Segment created! .","title":"Create a Segment"},{"location":"getting_started/#create-a-constraint","text":"Constraints are used to target a specific segment. Note Constraints are not required to match a segment. A segment with no constraints will match every request by default. To create a constraint: On the Segment Details page for the new segment you created, click New Constraint . Populate the details of the constraint as shown. Click Add Constraint . You should see the message Constraint added! . Click Segments in the navigation menu and you should now see your newly created segment in the list.","title":"Create a Constraint"},{"location":"getting_started/#creating-a-rule-and-distributions","text":"Finally we'll create a rule and set of distributions for your flag and variants. Rules and distributions allow you to define which variant gets returned when you evaluate a specific flag that falls into a given segment. To create a rule and distribution: Go back to the flag you created at the beginning. Click Targeting . Click New Rule . Under Segment: choose the segment you created earlier. Under Then serve: choose A Percentage Rollout . You should see your two variants that you created earlier, with a percentage of 50% each next to them. Click Add Rule . You should see the message Rule added! . You just created your first rule and distribution. A distribution is a way of assigning a percentage for which entities evaluated get a specific variant. The higher the percentage assigned, the more likely it is that any entity will get that specific variant. Note You could just as easily have picked a single variant instead of A Percentage Rollout when setting up your rule. This would effectively mean you have a single distribution, a variant with 100% chance of being returned.","title":"Creating a Rule and Distributions"},{"location":"getting_started/#evaluating-with-the-debug-console","text":"After creating the above flag, segment and targeting rule, you're now ready to test how this would work in your application. Fortunately the Flipt UI contains a Debug Console to allow you to experiment with different evaluation requests to see how they would be evaluated. The main ideas behind how evaluation works is described in more detail in the Concepts documentation. To test evaluation: Navigate to the Targeting section for your flag that you created above. Scroll down to the Debug Console section and click into the left pane where you will see a JSON payload. This represents the body of the request that will be evaluated. Notice the flagKey matches the key field of your flag. Notice that entityId is prepopulated with a random UUID. This represents the ID that you would use to uniquely identify entities (ex: users) that you want to test against your flags. Note that the context object is prepopulated as well. This corresponds to the properties that will be evaluated to determine if your request matches any constraints of your segments. Update the context object as shown. Click Debug . Note the Response pane to the right has been populated with the evaluation response from the server, informing you that this request would match your segment that you created earlier, and return one of the variants defined. Experiment with different values for the context and entityId fields. Tip You can click Reset to populate a new example request in the Request pane. This will also generate a fresh UUID for the entityId field. That's it! You're now ready to integrate Flipt into your application and start defining your own flags and segments that will enable you to seamlessly rollout new features to your users while reducing risk.","title":"Evaluating with the Debug Console"},{"location":"installation/","text":"Installation Docker The simplest way to run Flipt is via Docker. This streamlines the installation and configuration by using a reliable runtime. Prerequisites Docker installation is required on the host, see the official installation docs . Note Using a native Docker install instead of Docker Toolbox is recommended in order to use persisted volumes. Run the image docker run -d \\ -p 8080 :8080 \\ -p 9000 :9000 \\ -v $HOME /flipt:/var/opt/flipt \\ markphelps/flipt:latest This will download the image and start a Flipt container and publish ports needed to access the UI and backend server. All persistent Flipt data will be stored in $HOME/flipt . Note $HOME/flipt is just used as an example, you can use any directory you would like on the host. The Flipt container uses host mounted volumes to persist data: Host location Container location Purpose $HOME/flipt /var/opt/flipt For storing application data This allows data to persist between Docker container restarts. Warning If you don't use mounted volumes to persist your data, your data will be lost when the container exits! After starting the container you can visit http://0.0.0.0:8080 to view the application. Download from GitHub You can always download the latest release archive for your architecture from the Releases section on GitHub. This archive contains the Flipt binary, configuration, database migrations, README, LICENSE and CHANGELOG files. Copy the binary, config file and migrations to an accessible location on your host. Note You will need to update the config file: default.yml if your migrations and database locations differ from the standard locations. Run the Flipt binary with: ./flipt --config PATH_TO_YOUR_CONFIG See the Configuration section for more details.","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#docker","text":"The simplest way to run Flipt is via Docker. This streamlines the installation and configuration by using a reliable runtime.","title":"Docker"},{"location":"installation/#prerequisites","text":"Docker installation is required on the host, see the official installation docs . Note Using a native Docker install instead of Docker Toolbox is recommended in order to use persisted volumes.","title":"Prerequisites"},{"location":"installation/#run-the-image","text":"docker run -d \\ -p 8080 :8080 \\ -p 9000 :9000 \\ -v $HOME /flipt:/var/opt/flipt \\ markphelps/flipt:latest This will download the image and start a Flipt container and publish ports needed to access the UI and backend server. All persistent Flipt data will be stored in $HOME/flipt . Note $HOME/flipt is just used as an example, you can use any directory you would like on the host. The Flipt container uses host mounted volumes to persist data: Host location Container location Purpose $HOME/flipt /var/opt/flipt For storing application data This allows data to persist between Docker container restarts. Warning If you don't use mounted volumes to persist your data, your data will be lost when the container exits! After starting the container you can visit http://0.0.0.0:8080 to view the application.","title":"Run the image"},{"location":"installation/#download-from-github","text":"You can always download the latest release archive for your architecture from the Releases section on GitHub. This archive contains the Flipt binary, configuration, database migrations, README, LICENSE and CHANGELOG files. Copy the binary, config file and migrations to an accessible location on your host. Note You will need to update the config file: default.yml if your migrations and database locations differ from the standard locations. Run the Flipt binary with: ./flipt --config PATH_TO_YOUR_CONFIG See the Configuration section for more details.","title":"Download from GitHub"},{"location":"integration/","text":"Integration This document describes how to integrate Flipt in your existing applications. To learn how to install and run Flipt, see the Installation documentation. Once you have the Flipt server up and running within your infrastructure, the next step is to integrate the Flipt client(s) with your applications that you would like to be able to use with Flipt. There are two ways to communicate with the Flipt server: GRPC REST API Flipt GRPC Clients Since Flipt is a GRPC enabled application (see: Architecture ), to communicate with the Flipt server, you can use a generated GRPC client for your language of choice. This means that your application can use the Flipt GRPC client if it is written in one of the many languages that GRPC supports, including: C++ Java Python Go Ruby C# Node.js Android Java Objective-C PHP The Flipt GRPC client is the preferred way to integrate your application with Flipt as it is more performant than REST and requires the least amount of configuration. An example Go application exists at https://github.com/markphelps/flipt/examples/basic , showing how you would integrate with Flipt using the Go GRPC client. Download Prebuilt Flipt GRPC clients are currently available for the following languages: Go: https://github.com/markphelps/flipt-grpc-go If your language is not listed, please see the section below on how to generate a native GRPC client manually. If you choose to open source this client, please submit a pull request so I can add it to the docs. Generate If a GRPC client in your language is not available for download, you can easily generate it yourself using the existing protobuf definition . The GRPC documentation has extensive examples on how to generate GRPC clients in each supported language. Note GRPC generates both client implementation and the server interfaces. To use Flipt you only need the GRPC client implementation and can ignore the server code as this is implemented by Flipt itself. Below are two examples on how to generate Flipt clients in both Go and Ruby. Go Example Follow setup here: https://grpc.io/docs/quickstart/go/ Generate using protoc to desired location: $ protoc -I ./rpc --go_out = plugins = grpc:/tmp/flipt/go ./rpc/flipt.proto $ cd /tmp/flipt/go/flipt $ ls flipt.pb.go flipt_pb.rb flipt_services_pb. Ruby Example Follow setup here: https://grpc.io/docs/quickstart/ruby/ Generate using protoc to desired location: $ grpc_tools_ruby_protoc -I ./rpc --ruby_out = /tmp/flipt/ruby --grpc_out = /tmp/flipt/ruby ./rpc/flipt.proto $ cd /tmp/flipt/ruby $ ls flipt_pb.rb flipt_services_pb.rb Flipt REST API Flipt also comes equipped with a fully functional REST API. In fact, the Flipt UI is completely backed by this same API. This means that anything that can be done in the Flipt UI can also be done via the REST API. The Flipt REST API can also be used with any language that can make HTTP requests. This means that you don't need to use one of the above GRPC clients in order to integrate your application with Flipt. The latest version of the REST API is fully documented using OpenAPI v2 (formerly Swagger) specification available here . Each Flipt server instance also hosts it's own REST API documentation. This documentation is reachable in the Flipt UI by clicking the API link in the header navigation. This will load the API documentation which documents valid requests/responses to the Flipt REST API: Flipt REST Clients Generate You can use swagger-codegen to generate client code in your prefered language from the OpenAPI v2 specification linked above. While generating clients in all languages supported by swagger-codegen is outside of the scope of this documentation, an example of generating a Java client is below. Java Example Install swagger-codegen : https://github.com/swagger-api/swagger-codegen#prerequisites Generate using swagger-codegen to desired location: swagger-codegen generate -i swagger/api/swagger.json -l java -o /tmp/flipt/java Third-Party Client Libraries Client libraries built by awesome people from the Open Source community: Camji55/Flipt-iOS-SDK - Native iOS SDK for Flipt (Swift) christopherdiehl/rflipt - React components/example project to control React features backed by Flipt (React)","title":"Integration"},{"location":"integration/#integration","text":"This document describes how to integrate Flipt in your existing applications. To learn how to install and run Flipt, see the Installation documentation. Once you have the Flipt server up and running within your infrastructure, the next step is to integrate the Flipt client(s) with your applications that you would like to be able to use with Flipt. There are two ways to communicate with the Flipt server: GRPC REST API","title":"Integration"},{"location":"integration/#flipt-grpc-clients","text":"Since Flipt is a GRPC enabled application (see: Architecture ), to communicate with the Flipt server, you can use a generated GRPC client for your language of choice. This means that your application can use the Flipt GRPC client if it is written in one of the many languages that GRPC supports, including: C++ Java Python Go Ruby C# Node.js Android Java Objective-C PHP The Flipt GRPC client is the preferred way to integrate your application with Flipt as it is more performant than REST and requires the least amount of configuration. An example Go application exists at https://github.com/markphelps/flipt/examples/basic , showing how you would integrate with Flipt using the Go GRPC client.","title":"Flipt GRPC Clients"},{"location":"integration/#download","text":"Prebuilt Flipt GRPC clients are currently available for the following languages: Go: https://github.com/markphelps/flipt-grpc-go If your language is not listed, please see the section below on how to generate a native GRPC client manually. If you choose to open source this client, please submit a pull request so I can add it to the docs.","title":"Download"},{"location":"integration/#generate","text":"If a GRPC client in your language is not available for download, you can easily generate it yourself using the existing protobuf definition . The GRPC documentation has extensive examples on how to generate GRPC clients in each supported language. Note GRPC generates both client implementation and the server interfaces. To use Flipt you only need the GRPC client implementation and can ignore the server code as this is implemented by Flipt itself. Below are two examples on how to generate Flipt clients in both Go and Ruby.","title":"Generate"},{"location":"integration/#go-example","text":"Follow setup here: https://grpc.io/docs/quickstart/go/ Generate using protoc to desired location: $ protoc -I ./rpc --go_out = plugins = grpc:/tmp/flipt/go ./rpc/flipt.proto $ cd /tmp/flipt/go/flipt $ ls flipt.pb.go flipt_pb.rb flipt_services_pb.","title":"Go Example"},{"location":"integration/#ruby-example","text":"Follow setup here: https://grpc.io/docs/quickstart/ruby/ Generate using protoc to desired location: $ grpc_tools_ruby_protoc -I ./rpc --ruby_out = /tmp/flipt/ruby --grpc_out = /tmp/flipt/ruby ./rpc/flipt.proto $ cd /tmp/flipt/ruby $ ls flipt_pb.rb flipt_services_pb.rb","title":"Ruby Example"},{"location":"integration/#flipt-rest-api","text":"Flipt also comes equipped with a fully functional REST API. In fact, the Flipt UI is completely backed by this same API. This means that anything that can be done in the Flipt UI can also be done via the REST API. The Flipt REST API can also be used with any language that can make HTTP requests. This means that you don't need to use one of the above GRPC clients in order to integrate your application with Flipt. The latest version of the REST API is fully documented using OpenAPI v2 (formerly Swagger) specification available here . Each Flipt server instance also hosts it's own REST API documentation. This documentation is reachable in the Flipt UI by clicking the API link in the header navigation. This will load the API documentation which documents valid requests/responses to the Flipt REST API:","title":"Flipt REST API"},{"location":"integration/#flipt-rest-clients","text":"","title":"Flipt REST Clients"},{"location":"integration/#generate_1","text":"You can use swagger-codegen to generate client code in your prefered language from the OpenAPI v2 specification linked above. While generating clients in all languages supported by swagger-codegen is outside of the scope of this documentation, an example of generating a Java client is below.","title":"Generate"},{"location":"integration/#java-example","text":"Install swagger-codegen : https://github.com/swagger-api/swagger-codegen#prerequisites Generate using swagger-codegen to desired location: swagger-codegen generate -i swagger/api/swagger.json -l java -o /tmp/flipt/java","title":"Java Example"},{"location":"integration/#third-party-client-libraries","text":"Client libraries built by awesome people from the Open Source community: Camji55/Flipt-iOS-SDK - Native iOS SDK for Flipt (Swift) christopherdiehl/rflipt - React components/example project to control React features backed by Flipt (React)","title":"Third-Party Client Libraries"},{"location":"licensing/","text":"Licensing There are currently two types of licenses in place for Flipt: Client License Server License Client License All of the code required to generate GRPC clients in other languages as well as the existing GRPC Go client are licensed under the MIT License . This code exists in the rpc/ directory. The client code is the code that you would integrate into your applications, which is why a more permissive license is used. Server License The server code is licensed under the GPL 3.0 License . If there are any concerns about the use of this license for the server, please open an issue on GitHub so that we can discuss publicly.","title":"Licensing"},{"location":"licensing/#licensing","text":"There are currently two types of licenses in place for Flipt: Client License Server License","title":"Licensing"},{"location":"licensing/#client-license","text":"All of the code required to generate GRPC clients in other languages as well as the existing GRPC Go client are licensed under the MIT License . This code exists in the rpc/ directory. The client code is the code that you would integrate into your applications, which is why a more permissive license is used.","title":"Client License"},{"location":"licensing/#server-license","text":"The server code is licensed under the GPL 3.0 License . If there are any concerns about the use of this license for the server, please open an issue on GitHub so that we can discuss publicly.","title":"Server License"}]}